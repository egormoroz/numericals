import numpy as np
from math import pi

'''
Альтернативный способ выбора точек интерполяции на отрезке [a; b].
Минимизирует оценку ошибки интерполирования
'''
def alterspace(a, b, n=100):
    x = np.cos((2*np.arange(n, dtype=np.float64) + 1) / (2*n) * pi)
    x *= b - a
    x += b + a
    x *= 0.5
    return np.flip(x)

# Сплайн 10 (т.е. интерполируем просто ломаной, соединяющей точки)
def spline10(xs, ys, x):
    # Здесь две операции:
    # 1. Поиск отрезка, в котором лежит точка х. Поскольку табличные точки
    #    xs отсортированы по порядку, мы используем searchsorted. 
    #    Он возвращает номер правой точки отрезка.
    # 2. Ограничиваем номер слева 1 и справа n - 1. i = 0 или n если точка х
    #    выходит за границы отрезка [min(xs); max(xs)]. Чтобы интерполировать такую точку,
    #    мы просто "продливаем" граничные отрезки.
    i = np.clip(np.searchsorted(xs, x), 1, len(xs) - 1)
    # Отрезок, которому принадлежит х, задан двумя граничными точками.
    # На этом отрезке нам известно значение х, надо найти у. Для этого
    # можно разрешить уравнение прямой относительно у, но здесь использована
    # формула интерполяционного полинома Лагранжа для полинома 1й степени 
    # (ну т.е. полинома p(x) = ax + b), построенного как раз по двум граничным точкам.
    y = (x - xs[i]) / (xs[i-1] - xs[i]) * ys[i-1]
    y += (x - xs[i-1]) / (xs[i] - xs[i-1]) * ys[i]
    return y


'''
Построить сплайн степени 2 и гладкости 1 (т.е. S21) по n точкам.
Каждый кусочек сплайна - полином вида ax^2 + bx + c, т.е. всего 3 неизвестных.
Так что всего n - 1 отрезок и 3(n-1) = 3n - 3 неизвестных.

Соседние сплайны должны состыковываться в узловых точках.
Это даёт 2n - 2 уравнений. 

Условие совпадения производных даёт ещё n - 2 уравнения, так что сейчас у нас 
2n - 2 + n - 2 = 3n - 4 уравнений. Не хватает одного уравнения, так что мы добавляем
ещё одно граничное условие на производную 
(здесь потребовали, чтобы производная в правой границе была равна нулю).

Эта система здесь составляется и затем решается с помощью np.linalg.solve

Возвращает матрицу с коэффициентами полиномов.
'''
def build_spline21(xs, ys):
    n = len(xs) - 1
    A = np.zeros((3 * n, 3 * n))
    b = np.zeros(3 * n)

    for i in range(n):
        A[3*i + 0, 3*i:3*i + 3] = [1, xs[i], xs[i]**2]
        A[3*i + 1, 3*i:3*i + 3] = [1, xs[i+1], xs[i+1]**2]
        if i + 1 < n:
            A[3*i + 2, 3*i:3*i + 6] = [
                0, 1, 2*xs[i+1], 0, -1, -2*xs[i+1]]

        b[3*i:3*i+2] = [ys[i], ys[i+1]]

    A[-1, -2:] = [1, 2*xs[-1]]
    b[-1] = 0

    p = np.linalg.solve(A, b).reshape((n, 3))
    return np.flip(p, axis=1).T


'''
Аналогично сплайну build_spline32, только здесь уже:
    1. Кубические полиномы
    2. Совпадение не только первых, но ещё и вторых производных в соседних точках.
    3. Два граничных условия (dfa, dfb - значения df(a)/dx и df(b)/dx)
'''
def build_spline32(xs, ys, dfa, dfb):
    n = len(xs) - 1
    A = np.zeros((n*4, n*4))
    b = np.zeros(n*4)

    for i in range(n):
        b[4*i:4*i+2] = [ys[i], ys[i+1]]

        A[4*i + 0, 4*i:4*i+4] = [1, xs[i], xs[i]**2, xs[i]**3]
        A[4*i + 1, 4*i:4*i+4] = [1, xs[i+1], xs[i+1]**2, xs[i+1]**3]

        if i + 1 == n:
            continue
        A[4*i + 2, 4*i:4*i+8] = [
            0, 1, 2*xs[i+1], 3*xs[i+1]**2, 
            0, -1, -2*xs[i+1], -3*xs[i+1]**2, 
        ]
        A[4*i + 3, 4*i:4*i+8] = [
            0, 0, 2, 6*xs[i+1],
            0, 0, -2, -6*xs[i+1],
        ]

    A[-2, :4] = [0, 1, 2*xs[0], 3*xs[0]**2]
    A[-1, -4:] = [0, 1, 2*xs[-1], 3*xs[-1]**2]
    b[-2] = dfa
    b[-1] = dfb

    p = np.linalg.solve(A, b).reshape((n, 4))
    return np.flip(p, axis=1).T


'''
Вычислить значения сплайна с коэфициэнтами p 
и табличными точками xs в точках х.
'''
def spline(xs, p, x):
    # Аналогичный ход, как и в spline10, читать пояснение там.
    i = np.clip(np.searchsorted(xs, x) - 1, 0, len(xs) - 2)
    # Вычислить значения полиномов, соответсвующих отрезкам, где лежит x
    return np.polyval(p[:, i], x)


# Функция, по которой составляем таблицу для интерполирования
def f(x):
    return x + np.log10(x/5)


# Производная этой функции
def derf(x):
    return 1 + 1/(np.log(10) * x)


'''
Протестить интерполирование сплайном spl на отрезке [a; b]
по разному колву точек (от 2 до max_n) 
и посчитать ошибку в тестовых точках, всего которых k штук.
'''
def run(a, b, max_n, k, spl):
    x_test = np.linspace(a, b, k)
    y_test = f(x_test)
    for n in range(2, max_n+1):
        xs = np.linspace(a, b, n)
        iy_test = spl(xs, f(xs), x_test)
        dev = np.max(np.abs(y_test - iy_test))

        xs = alterspace(a, b, n)
        iy_test = spl(xs, f(xs), x_test)
        dev_opt = np.max(np.abs(y_test - iy_test))

        print('{:02d} {} {:.4e} {:.4e}'.format(
                n, k, dev, dev_opt))


a, b = 1, 2
max_n, k = 50, 1000


def spl21(xs, ys, x):
    return spline(xs, build_spline21(xs, ys), x)


def spl32(xs, ys, x):
    p = build_spline32(xs, ys, derf(a), derf(b))
    return spline(xs, p, x)


def main():
    print('S10')
    run(a, b, max_n, k, spline10)
    print('S21')
    run(a, b, max_n, k, spl21)
    print('S32')
    run(a, b, max_n, k, spl32)


if __name__ == '__main__':
    main()
